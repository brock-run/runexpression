# RunExpression: AI Agent Development Guide

**Last Generated:** 2025-12-15
**Auto-generated from:** DOCS/*.md, docs/adr/*.md

> ⚠️ **DO NOT EDIT THIS FILE DIRECTLY**
>
> This file is auto-generated from source documentation. To update this guide:
> 1. Edit the source documentation in DOCS/ or docs/adr/
> 2. Run: `node scripts/generate-ai-agent-guide.js`
> 3. Commit both source docs and regenerated guide

---

## Purpose

This guide provides AI agents (like Claude, GitHub Copilot, etc.) with comprehensive context about RunExpression's architecture, conventions, and patterns. Use this as a reference when:

- Writing new features
- Fixing bugs
- Reviewing code
- Making architectural decisions
- Answering questions about the codebase

---

## Quick Reference

### Tech Stack
- **Frontend:** Next.js 14+ (App Router), React, TypeScript, Tailwind CSS, Shadcn/UI
- **Backend:** Supabase (PostgreSQL + Auth + Storage + Realtime)
- **Payments:** Stripe (Hosted Checkout)
- **Content:** MDX (next-mdx-remote)
- **Animations:** Framer Motion
- **Deployment:** Vercel

### Project Structure
```
/app/              # Next.js App Router pages
  (public)/        # Public routes (no auth)
  (flow)/          # Flow feature routes
  (app)/           # Authenticated routes
  api/             # API routes
/components/       # React components
  ui/              # Shadcn/UI components
  flow/            # Flow-specific components
  clubhouse/       # Clubhouse-specific components
/lib/              # Utilities and helpers
  supabase/        # Supabase clients
  types/           # TypeScript types
/DOCS/             # Core documentation
/docs/adr/         # Architectural Decision Records
```

### Key Commands
```bash
npm run dev        # Start development server
npm run build      # Build for production
npm run lint       # Run ESLint
npm run test       # Run tests
npm run type-check # TypeScript type checking
```

---

## Core Documentation

> Source: `DOCS/`

### 01-OVERVIEW

**File:** `DOCS/01-OVERVIEW.md`

*[Full details in DOCS/01-OVERVIEW.md]*

---

### 02-PRODUCT-REQUIREMENTS

**File:** `DOCS/02-PRODUCT-REQUIREMENTS.md`

**Overview:**
A scroll-driven, motion-enhanced landing page that weaves the "Expressive Runner's Creed" into an interactive narrative. This is the brand's front door and primary conversion surface.

### Key Components

#### F1.1: Hero Section
**Purpose:** Immediate brand positioning and CTA

**Elements:**
- **H1:** "Make running mean more."
- **Subheadline:** "Turn your struggle into art and feed the running community with your story."
- **Primary CTA:** "Enter the Flow" (links to canvas)
- **Secondary CTA:** "Visit the Clubhouse" (links to DWTC)
- **Visual:** Subtle motion (slow-shutter run scene or flowing abstract lines)

**Behavior:**
- CTAs sticky or prominently positioned throughout scroll
- Mobile: Stack CTAs vertically, ensure thumb-reachable
- Desktop: Side-by-side CTAs

#### F1.2: Manifesto Chapters (Scroll Sections)
**Purpose:** Educate visitors on the four brand pillars through progressive revelation

**Chapters:**

**Chapter 1: Motion Creates Emotion**
- Headline: "Leave heavy. Return light."
- Body: "We've all felt it. You lace up with a head full of noise, stress, and unfinished arguments. Three miles later, the noise settles..."
- Soft CTA: "Explore the Mindset →"

**Chapter 2: Process Over Outcome**
- Headline: "We take our fun very seriously."
- Body: "Let's be honest: in the grand scheme of the universe, running in circles is ridiculous. We pay to wake up at 4 AM..."
- Soft CTA: "Embrace the Grind →"

**Chapter 3: Interdependence**
- Headline: "Your squad is your battery pack."
- Body: "Science confirms what the gut already knows: We go farther when we go together..."
- Soft CTA: "Find Your Crew →"

**Chapter 4: Living Laboratory**
- Headline: "Enlightenment smells like laundry."
- Body: "We run to find clarity, patience, and creativity that we can bring back to our 'real lives'..."
- Soft CTA: "Bring It to Life →"

**Interaction Pattern:**
- Scroll-triggered reveals (Framer Motion)
- Fade-in headline first, then body text
- Subtle parallax on background images
- Each chapter occupies ~60-80% of viewport height

#### F1.3: Flow Preview Strip
**Purpose:** Show live community activity; tease The Flow experience

**Elements:**
- **H2:** "What are we running for today?"
- **Subheadline:** "You are not alone on the road."
- **Live feed:** Horizontal auto-scroll of recent Flow submissions (text snippets)
- **CTA:** "Add Your Voice →" (links to full canvas)

**Behavior:**
- Shows most recent 20-30 approved submissions
- Auto-scrolls or swipeable on mobile
- Clicking a snippet could expand it (V1.1 feature)

#### F1.4: Clubhouse Teaser
**Purpose:** Drive DWTC members to clubhouse; introduce concept to others

**Elements:**
- **H2:** "Welcome to the Laboratory."
- **Body:** "The Clubhouse is where the 'Sage in the Parking Lot' lives. It's where we swap stories, dissect the process..."
- **Callout:** "This is an invitation. Not to run faster, but to run deeper."
- **CTA:** "Visit the Clubhouse →"
- **Visual:** Gritty, high-grain photography (black & white DWTC crew photo)

#### F1.5: Footer
**Elements:**
- **Headline:** "Run for yourself. Run for us. Express yourself."
- **Navigation:** The Manifesto, The Flow, The Studio, The Shop, Login/Join
- **Social links:** Instagram, Strava(?), Email
- **Legal:** Privacy Policy, Terms of Service
- **Copyright:** © 2025 Run Expression

### Acceptance Criteria

- [ ] Homepage loads in <2s (LCP)
- [ ] All four manifesto chapters render with scroll-triggered animations
- [ ] Animations respect `prefers-reduced-motion` setting
- [ ] CTAs functional on all devices
- [ ] Flow preview strip shows real data from database
- [ ] Mobile responsive (320px to 1920px widths)
- [ ] Copy matches approved brand voice
- [ ] All links navigate correctly
- [ ] Footer social links open in new tabs
- [ ] Analytics events fire: `homepage_view`, `cta_click`, `scroll_depth`

---

*[Full details in DOCS/02-PRODUCT-REQUIREMENTS.md]*

---

### 03-TECHNICAL-DESIGN

**File:** `DOCS/03-TECHNICAL-DESIGN.md`

*[Full details in DOCS/03-TECHNICAL-DESIGN.md]*

---

### 04-BRAND-CONTENT-GUIDE

**File:** `DOCS/04-BRAND-CONTENT-GUIDE.md`

*[Full details in DOCS/04-BRAND-CONTENT-GUIDE.md]*

---

### 05-IMPLEMENTATION-PLAN

**File:** `DOCS/05-IMPLEMENTATION-PLAN.md`

*[Full details in DOCS/05-IMPLEMENTATION-PLAN.md]*

---

### 06-DATA-SCHEMA

**File:** `DOCS/06-DATA-SCHEMA.md`

*[Full details in DOCS/06-DATA-SCHEMA.md]*

---

### 07-CODING-STANDARDS

**File:** `DOCS/07-CODING-STANDARDS.md`

**Overview:**
This document defines coding standards for RunExpression V1. All code (TypeScript, React, CSS) should follow these conventions to ensure consistency, maintainability, and scalability.

**Goals:**
- **Consistency:** Code looks like it was written by one person
- **Readability:** New developers can understand code quickly
- **Maintainability:** Easy to modify without breaking things
- **Performance:** Follow patterns that optimize bundle size and runtime
- **Type Safety:** Leverage TypeScript to catch bugs at compile time

---

*[Full details in DOCS/07-CODING-STANDARDS.md]*

---

### 08-DATABASE-CONVENTIONS

**File:** `DOCS/08-DATABASE-CONVENTIONS.md`

**Overview:**
This document defines database conventions for RunExpression V1. All database schema, queries, and migrations should follow these standards to ensure consistency, performance, and maintainability.

**Database:** PostgreSQL 15+ (via Supabase)
**Schema Approach:** Hybrid relational + JSONB (see [ADR-004](../docs/adr/004-hybrid-schema.md))

**Goals:**
- **Clear naming:** Table and column names are self-documenting
- **Type safety:** Database types map cleanly to TypeScript
- **Security:** RLS policies enforce access control
- **Performance:** Indexes optimize common queries
- **Flexibility:** JSONB allows schema evolution

---

*[Full details in DOCS/08-DATABASE-CONVENTIONS.md]*

---

### 09-UI-UX-PATTERNS

**File:** `DOCS/09-UI-UX-PATTERNS.md`

**Overview:**
This document defines UI/UX patterns for RunExpression V1. All interfaces should follow these standards to ensure consistency, accessibility, and brand alignment.

**Design Philosophy:**
- **Expressive, not minimal:** Embrace personality (purple glows, monospace fonts)
- **Accessible by default:** WCAG 2.1 AA compliance minimum
- **Motion with purpose:** Animations enhance meaning, not distraction
- **Generous spacing:** Let content breathe (sage runner philosophy)
- **Progressive disclosure:** Show complexity gradually

**Brand Aesthetic:**
- **Colors:** Sage green (#6B7F6E), purple (#8B5CF6), cream (#F5F5DC)
- **Typography:** Monospace (DM Mono) for UI, serif (Merriweather) for body text
- **Tone:** Serious but lighthearted, deep but accessible ("Sage in the parking lot")

---

*[Full details in DOCS/09-UI-UX-PATTERNS.md]*

---

### 10-GIT-WORKFLOW

**File:** `DOCS/10-GIT-WORKFLOW.md`

**Overview:**
This document defines Git workflow and version control conventions for RunExpression V1. All contributors should follow these standards to maintain a clean, organized repository.

**Goals:**
- **Clear history:** Commit messages tell the story of the project
- **Safe collaboration:** Branches protect main from breaking changes
- **Easy rollbacks:** Clean commits make reverting changes simple
- **Automated quality:** Hooks enforce standards before commits/pushes

---

*[Full details in DOCS/10-GIT-WORKFLOW.md]*

---

## Architectural Decision Records

> Source: `docs/adr/`

### 000-template

**File:** `docs/adr/000-template.md`

---

### 001-nextjs-app-router

**File:** `docs/adr/001-nextjs-app-router.md`

**Context:**
RunExpression V1 requires a frontend framework that can deliver:
- **SEO-optimized content** for the manifesto, blog, and public pages
- **Interactive, real-time features** for The Flow canvas and clubhouse
- **Server-side and client-side rendering** flexibility
- **Modern developer experience** with TypeScript support
- **Production-ready deployment** with minimal configuration

The application has three distinct experiences:
1. Public marketing (homepage, blog) - needs SSR/SSG for SEO
2. Interactive canvas (The Flow) - needs CSR and real-time updates
3. Authenticated clubhouse - needs both SSR (initial load) and CSR (interactions)

Additionally, the AI Coach platform will eventually share the same codebase, requiring a scalable foundation.

**Decision:**
We will use **Next.js 14+ with the App Router** as our frontend framework.

### Key Implementation Details:

- **App Router** (`app/` directory) for modern routing and Server Components
- **Server Components by default** for initial renders and SEO
- **Client Components** (`"use client"`) for interactivity
- **Route Groups** to organize pages by access level: `(public)`, `(flow)`, `(app)`
- **TypeScript** throughout for type safety
- **Deployed on Vercel** for zero-config hosting

**Key Consequences:**
### Positive

- **Best-in-class SEO:** Server-side rendering with automatic metadata handling
- **Performance:** React Server Components reduce client-side bundle size
- **Developer experience:** Hot reload, TypeScript support, great documentation
- **Deployment synergy:** Vercel is built for Next.js (edge functions, preview deployments)
- **Flexibility:** Can use SSR, SSG, or CSR per page/component as needed
- **Image optimization:** Built-in `<Image>` component with automatic WebP conversion
- **Future-ready:** App Router is the future of Next.js (Pages Router is legacy)
- **AI Coach integration:** Same stack can power future AI features

*[Full details in docs/adr/001-nextjs-app-router.md]*

---

### 002-supabase-backend

**File:** `docs/adr/002-supabase-backend.md`

**Context:**
RunExpression V1 requires a backend solution that provides:
- **PostgreSQL database** with relational integrity and JSONB flexibility
- **Authentication** with email/password and OAuth providers
- **File storage** for user-uploaded images, videos, and documents
- **Real-time capabilities** for The Flow wall updates
- **Row Level Security (RLS)** for multi-tenant data access control
- **Generous free tier** to minimize initial costs
- **Future AI Coach compatibility** using the same database

The application needs to:
- Store structured data (users, clubs, products) relationally
- Store flexible data (vibe tags, metadata) in JSONB
- Handle file uploads from browsers (The Flow images, clubhouse media)
- Push new Flow entries to clients in real-time without polling
- Enforce access control (club members only see their club data)

Strategic requirement: **The AI Coach will eventually use the same database** to access user profiles, running history, and community context.

**Decision:**
We will use **Supabase** as our Backend-as-a-Service platform, providing:
- PostgreSQL database (managed)
- Built-in authentication (Supabase Auth with JWT)
- File storage (Supabase Storage, S3-compatible)
- Real-time subscriptions (WebSocket-based)
- Auto-generated REST and GraphQL APIs
- Row Level Security enforcement at database level

### Key Implementation Details:

- **Database:** PostgreSQL 15+ with hybrid relational + JSONB schema
- **Auth:** Supabase Auth with email/password (OAuth deferred to V1.1)
- **Storage:** Supabase Storage buckets (`uploads`, `products`, `avatars`)
- **Realtime:** Subscribe to `expression_events` table for live Flow updates
- **RLS Policies:** All security enforced at database level (see ADR-004)
- **Client Libraries:** `@supabase/ssr` for Next.js App Router integration

**Key Consequences:**
### Positive

- **All-in-one platform:** Database, auth, storage, realtime in one service (reduces complexity)
- **PostgreSQL power:** Full SQL capabilities, ACID compliance, advanced querying
- **RLS enforcement:** Security at database level, can't be bypassed by buggy application code
- **Generous free tier:** 500MB database, 1GB file storage, 50K monthly active users (sufficient for V1)
- **Real-time built-in:** No need for separate WebSocket server or polling
- **Type safety:** Auto-generated TypeScript types from schema (`supabase gen types`)
- **AI Coach ready:** Same database used for future AI features, no data migration needed
- **Open source:** Can self-host if needed (though unlikely)

*[Full details in docs/adr/002-supabase-backend.md]*

---

### 003-pragmatic-monolith

**File:** `docs/adr/003-pragmatic-monolith.md`

**Context:**
RunExpression V1 includes multiple distinct experiences:
1. **Public marketing** (homepage, blog, manifesto)
2. **The Flow** (interactive canvas with real-time updates)
3. **DWTC Clubhouse** (authenticated, member-only area)
4. **Shop** (e-commerce with Stripe integration)
5. **Tools** (pace calculator, future interactive utilities)

We must decide: Should these be separate applications (microservices) or a single codebase (monolith)?

**Key Constraints:**
- **Small team:** 1-2 developers initially
- **Fast time-to-market:** 6-8 weeks to V1 launch
- **Shared context:** All features share user authentication and database
- **Future AI Coach:** Will integrate deeply with existing features
- **Limited budget:** Must minimize operational complexity and costs

**Strategic Goal:** Ship V1 quickly while maintaining clear path to scale when AI Coach launches.

**Decision:**
We will build RunExpression V1 as a **Pragmatic Monolith**: a single Next.js application containing all features, with clear internal boundaries and modular code organization.

### Key Implementation Details:

**Single Codebase:**
- One Next.js application
- One Supabase database
- One Vercel deployment
- Shared authentication across all features

**Internal Modularity:**
- Route groups for logical separation: `(public)`, `(flow)`, `(app)`, `(shop)`
- Feature-based component organization (`components/flow/`, `components/clubhouse/`)
- Shared utilities in `lib/` (auth, database clients, analytics)
- Clear API route structure (`api/flow/`, `api/clubhouse/`, `api/webhooks/`)

**Deliberate Constraints:**
- No microservices (yet)
- No separate databases per feature
- No complex service mesh or API gateway
- Simple deployment (single Vercel project)

**Key Consequences:**
### Positive

- **Faster development:** No inter-service communication, shared code, single deployment
- **Easier debugging:** All code in one place, single log stream
- **Simplified deployment:** One `git push` deploys entire app
- **Shared authentication:** User sessions work across all features naturally
- **Lower operational overhead:** One server, one database, one monitoring dashboard
- **Better developer experience:** Single dev environment, single `npm run dev`
- **Database transactions:** Features can share transactions (e.g., order + unlock digital content)
- **Cost efficiency:** No duplicate infrastructure, single Vercel/Supabase bill

*[Full details in docs/adr/003-pragmatic-monolith.md]*

---

### 004-hybrid-schema

**File:** `docs/adr/004-hybrid-schema.md`

**Context:**
RunExpression's data model includes:

**Well-defined entities:**
- Users (profiles, authentication)
- Clubs (DWTC and future clubs)
- Memberships (who belongs to which club)
- Products (shop items)
- Orders (purchase records)

**Flexible, evolving attributes:**
- User preferences ("Why do you run?", shoe size, injury history)
- Vibe tags for Flow submissions (Meditative, Aggressive, etc.)
- Club metadata (rituals, traditions, branding)
- Expression metadata (run context, perceived effort)

**Key Requirements:**
1. **Relational integrity:** Ensure memberships link valid users to valid clubs
2. **Flexible attributes:** Add new user preferences or vibe tags without schema migrations
3. **AI Coach readiness:** Store rich context (qualitative + quantitative) for future ML
4. **Query performance:** Fast lookups by relationships (user → clubs → contributions)
5. **Future evolution:** Schema must accommodate unknowns (new running metrics, new club types)

**Strategic Goal:** Balance structured data (relational) with flexibility (schemaless) to enable rapid iteration while maintaining data integrity.

**Decision:**
We will use a **Hybrid Relational + JSONB schema** in PostgreSQL:

- **Core entities** (users, clubs, memberships, products) as **relational tables** with foreign keys
- **Flexible attributes** (metadata, preferences, tags) stored in **JSONB columns**
- **Arrays** for simple lists (tags, vibe_tags)
- **Row Level Security (RLS)** for access control at database level

### Key Implementation Details:

**Relational Tables for Structure:**
```sql
profiles (id, email, full_name, created_at)
clubs (id, name, slug)
club_memberships (user_id, club_id, role)  -- FK to both
```

**JSONB Columns for Flexibility:**
```sql
profiles.expression_data JSONB  -- {bio, why_i_run, preferences}
clubs.manifesto JSONB           -- {rituals, branding, traditions}
expression_events.metadata JSONB  -- {run_distance, perceived_effort}
```

**Hybrid Example:**
```sql
-- User profile (relational + JSONB)
INSERT INTO profiles (id, email, full_name, expression_data) VALUES (
  uuid,
  'runner@example.com',
  'Sarah Runner',
  '{
    "bio": "Running for clarity",
    "why_i_run": "Community and growth",
    "shoe_size": "8.5",
    "preferred_distance": "10k",
    "injury_history": ["IT band 2023"]
  }'::jsonb
);

-- Query both relational and JSONB
SELECT full_name, expression_data->>'why_i_run' as motivation
FROM profiles WHERE email = 'runner@example.com';
```

**Key Consequences:**
### Positive

- **Schema evolution without migrations:** Add new JSONB fields instantly (no ALTER TABLE)
- **Relational integrity preserved:** Foreign keys prevent orphaned data (user deleted → memberships deleted)
- **Rich querying:** PostgreSQL's JSONB operators enable complex queries (`expression_data->>'shoe_size'`)
- **AI-ready data:** JSONB captures unstructured context (qualitative reflections, metadata)
- **Index support:** Can create GIN indexes on JSONB for fast lookups
- **Future-proof:** Can accommodate new running metrics, club types, user attributes
- **Type flexibility:** JSONB columns can evolve independently per row (some users have more fields)
- **Single database:** No need for separate NoSQL store

*[Full details in docs/adr/004-hybrid-schema.md]*

---

### 005-mdx-content

**File:** `docs/adr/005-mdx-content.md`

**Context:**
RunExpression V1 includes a blog/library section for long-form content:
- Philosophy essays ("The Expressive Runner's Creed")
- Training wisdom ("Process Over Outcome in Marathon Training")
- DWTC stories ("Why the Bacon Ritual Matters")
- Creative expression pieces (art, comics, playlists)

**Content Requirements:**
- **Rich formatting:** Headings, lists, quotes, images, code blocks
- **Interactive elements:** Embedded pace calculators, quote animations
- **Version control:** Track changes to articles over time
- **SEO-friendly:** Fast initial load, proper meta tags
- **Easy authoring:** Founder (non-technical) and developers both write content
- **Fast iteration:** Publish new posts quickly without backend changes

**Team Constraints:**
- Small team (1-2 devs)
- No dedicated content manager initially
- Want to avoid admin UI maintenance
- Prefer simple, file-based workflow

**Decision:**
We will use **MDX** (Markdown + React components) for blog content, rendered via `next-mdx-remote` in Next.js.

### Key Implementation Details:

**File Structure:**
```
/content/
  blog/
    expressive-runners-creed.mdx
    bacon-ritual.mdx
    process-over-outcome.mdx
```

**MDX Example:**
```mdx
---
title: "The Expressive Runner's Creed"
excerpt: "Why we run deeper, not just faster"
author: "Brock"
publishedAt: "2025-12-14"
tags: ["philosophy", "manifesto"]
---

# The Expressive Runner's Creed

We believe running is not just a physical act; it is a **creative one**.

<PaceCalculator />

Read on to understand why...
```

**Rendering:**
- Files read at build time or server-side
- `next-mdx-remote` serializes MDX → React components
- Custom React components embedded inline (calculators, quote blocks)
- Blog index auto-generated from file metadata

**Benefits:**
- Write in Markdown (familiar to everyone)
- Embed React components (interactive elements)
- Version controlled in Git (every change tracked)
- No database queries for content (fast)

**Key Consequences:**
### Positive

- **Simple workflow:** Create `.mdx` file, write content, commit, deploy
- **Version control:** Every edit tracked in Git history
- **Fast rendering:** Static or cached at CDN edge
- **React components:** Can embed pace calculator, Flow snippets, custom quote blocks
- **Type safety:** Frontmatter validated with Zod schemas
- **Portable:** MDX files can be moved to any framework (not locked to Next.js)
- **No admin UI to maintain:** No CMS backend to secure, update, or debug
- **Free:** No CMS hosting costs

*[Full details in docs/adr/005-mdx-content.md]*

---

### 006-stripe-hosted-checkout

**File:** `docs/adr/006-stripe-hosted-checkout.md`

**Context:**
RunExpression V1 includes a shop for physical and digital products:
- Physical: Runner greeting cards, t-shirts
- Digital: Training plan PDFs, handbook PDFs

**Payment Requirements:**
- Accept credit card payments securely
- Handle tax calculation (if applicable)
- Support one-time purchases (no subscriptions in V1)
- Deliver digital products automatically
- Provide order confirmation emails
- Minimize PCI compliance burden

**Team Constraints:**
- Small team, no payment specialist
- Must ship V1 quickly (6-8 weeks)
- Minimize security/compliance overhead
- Prefer managed solutions over custom code

**Decision:**
We will use **Stripe Hosted Checkout** for all payments. Users will be redirected to Stripe's hosted payment page, complete purchase there, then return to our site.

### Key Implementation Details:

**Flow:**
1. User clicks "Buy Now" on product page
2. Next.js API route creates Stripe Checkout Session
3. User redirected to `checkout.stripe.com`
4. User enters payment info on Stripe's page
5. Stripe processes payment
6. User redirected back to `/shop/success?session_id=xxx`
7. Webhook handler unlocks digital products (if applicable)

**Code Example:**
```typescript
// Create checkout session
const session = await stripe.checkout.sessions.create({
  line_items: [{ price: product.stripe_price_id, quantity: 1 }],
  mode: 'payment',
  success_url: `${origin}/shop/success?session_id={CHECKOUT_SESSION_ID}`,
  cancel_url: `${origin}/shop/cancel`,
});

// Redirect to Stripe
redirect(session.url);
```

**Key Consequences:**
### Positive

- **Zero PCI compliance burden:** Stripe handles all payment data (we never touch card numbers)
- **Secure by default:** Stripe's payment form is battle-tested and compliant
- **Fast implementation:** ~1 day to integrate vs. weeks for custom form
- **Mobile-optimized:** Stripe's checkout works perfectly on mobile
- **Tax handling:** Stripe can calculate tax if needed (Stripe Tax)
- **Email receipts:** Stripe sends email receipts automatically
- **Localization:** Stripe supports multiple currencies and languages
- **Fraud protection:** Stripe Radar included (machine learning fraud detection)

*[Full details in docs/adr/006-stripe-hosted-checkout.md]*

---

### 007-openai-moderation

**File:** `docs/adr/007-openai-moderation.md`

**Context:**
The Flow (interactive canvas) allows users to submit text and images that appear publicly. This creates moderation challenges:

**Risks:**
- Spam submissions
- Offensive language (hate speech, harassment)
- Inappropriate images (NSFW, violence)
- Self-harm content
- Brand damage if harmful content appears

**Requirements:**
- Prevent obviously harmful content from reaching admin queue
- Minimize manual moderation burden
- Fast response (users shouldn't wait >1s for submission)
- Cost-effective at scale (potentially thousands of submissions)
- Easy to implement (small team, fast V1 timeline)

**Team Constraints:**
- No dedicated moderator initially (founder handles moderation)
- Need automated first-pass filtering
- Manual review for edge cases acceptable

**Decision:**
We will use **OpenAI Moderation API** to automatically filter text submissions in real-time before they enter the moderation queue.

### Key Implementation Details:

**Flow:**
1. User submits text to The Flow
2. Next.js API route calls OpenAI Moderation API
3. If flagged (hate speech, harassment, etc.) → reject immediately with user-friendly error
4. If clean → proceed to trust scoring and admin queue (or auto-approve if trusted user)

**Code Example:**
```typescript
import OpenAI from 'openai';
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const moderation = await openai.moderations.create({
  input: userText
});

if (moderation.results[0].flagged) {
  return { error: 'Content flagged by moderation' };
}

// Proceed with submission...
```

**What OpenAI Checks:**
- Hate speech
- Harassment/threatening
- Self-harm
- Sexual content
- Violence

**What We Still Manually Review:**
- Images (OpenAI Moderation is text-only)
- Context/quality (is submission meaningful?)
- Spam (repetitive submissions)

**Key Consequences:**
### Positive

- **Fast filtering:** <500ms API response, blocks obvious violations instantly
- **Free tier sufficient:** 1M requests/month free (far exceeds V1 needs)
- **High accuracy:** OpenAI's model is well-trained on problematic content
- **Multi-language:** Works across languages (helpful as we grow internationally)
- **Reduces admin burden:** Founder doesn't see obviously harmful content
- **Brand protection:** Offensive content never enters our database
- **Easy integration:** Single API call, minimal code
- **Logging:** Store moderation results in metadata for analysis

*[Full details in docs/adr/007-openai-moderation.md]*

---

### 008-client-side-compression

**File:** `docs/adr/008-client-side-compression.md`

**Context:**
The Flow and DWTC Clubhouse allow users to upload images:
- Flow: Post-run photos (shoes, trails, moments)
- Clubhouse: Race photos, group runs, events

**Image Upload Challenges:**
- Modern phone cameras produce 5-10MB images
- Users upload from mobile (slow cellular networks)
- Supabase Storage has 1GB free tier limit
- Large images slow page load times
- CDN bandwidth costs scale with file size

**Requirements:**
- Accept images from any device (iPhone, Android, DSLR)
- Display images quickly on The Flow wall (~50+ images)
- Minimize storage costs
- Fast upload experience (mobile users shouldn't wait 30+ seconds)
- Maintain acceptable image quality

**Example:**
- User uploads 8MP iPhone photo: ~6MB raw
- Displayed on wall at 600x400px
- Storing 6MB wastes 90% of storage (only need ~400KB)

**Decision:**
We will **compress images client-side** (in the browser) before uploading to Supabase Storage.

### Key Implementation Details:

**Library:** `compressorjs` (or `browser-image-compression`)

**Compression Settings:**
- **Max width:** 1920px (4K displays still look good)
- **Quality:** 0.8 (JPEG quality, good balance)
- **Format:** Convert to JPEG (even if uploaded PNG)
- **Target size:** ~400KB (down from 5-10MB)

**Code Example:**
```typescript
import Compressor from 'compressorjs';

new Compressor(file, {
  quality: 0.8,
  maxWidth: 1920,
  success(compressedFile) {
    // Upload to Supabase Storage
    await supabase.storage.from('uploads').upload(path, compressedFile);
  },
  error(err) {
    console.error('Compression failed:', err);
  }
});
```

**Workflow:**
1. User selects image file (5MB)
2. Browser compresses to ~400KB
3. Upload compressed version
4. Progress bar shows upload status
5. Store public URL in database

**Key Consequences:**
### Positive

- **10-20x storage savings:** 5MB → 400KB per image (huge cost reduction)
- **Faster uploads:** 400KB uploads in 1-2s vs 30s for 5MB on 3G
- **Better UX:** Users see progress bar complete quickly
- **Faster page loads:** Flow wall with 50 images loads in <2s vs 10s+
- **Free tier lasts longer:** 1GB Supabase Storage = 2500 images vs 200 without compression
- **Lower bandwidth costs:** CDN serves 20x less data
- **Works offline-first:** Compression happens locally, even on spotty connection


*[Full details in docs/adr/008-client-side-compression.md]*

---

### 009-shadcn-ui

**File:** `docs/adr/009-shadcn-ui.md`

**Context:**
RunExpression V1 requires a robust UI component system for:
- Forms (login, waitlist, Flow submissions, club uploads)
- Interactive elements (dialogs, tooltips, dropdowns)
- Data display (cards, tables, lists)
- Navigation (menus, tabs)
- Feedback (toasts, alerts, loading states)

**UI Requirements:**
- **Accessible:** WCAG 2.1 AA compliance (keyboard nav, screen readers)
- **Customizable:** Must match RunExpression's unique brand (sage green, purple, monospace fonts)
- **Performant:** Minimal bundle size, tree-shakeable
- **Developer-friendly:** Fast to implement, TypeScript support, good DX
- **Consistent:** Reusable patterns across all pages

**Constraints:**
- Small team (1-2 devs) — can't build everything from scratch
- Tailwind CSS already chosen for styling
- Need to ship V1 in 6-8 weeks
- Brand is highly custom (not Material Design or Bootstrap aesthetic)

**Examples of Custom Needs:**
- Dialog overlays with purple glows (not default gray shadows)
- Monospace font buttons (not rounded sans-serif)
- Accordion sections for Clubhouse Lore (unique styling)
- Toast notifications with brand voice ("Your run was captured in The Flow")

**Decision:**
We will use **Shadcn/UI** — a collection of copy-paste React components built on Radix UI primitives, styled with Tailwind CSS.

### Key Implementation Details:

**What Shadcn/UI is:**
- **Not a library:** Components copied into your codebase (`/components/ui/`)
- **Built on Radix UI:** Uses Radix primitives (accessible, unstyled components)
- **Styled with Tailwind:** All styling via Tailwind classes
- **Customizable:** You own the code, modify as needed

**Installation Example:**
```bash
npx shadcn-ui@latest init
npx shadcn-ui@latest add button dialog form toast accordion
```

**Component Structure:**
```
/components/ui/
  button.tsx        # <Button variant="outline" size="lg" />
  dialog.tsx        # <Dialog><DialogTrigger>...</Dialog>
  form.tsx          # <Form> with react-hook-form integration
  toast.tsx         # Toast notifications
  accordion.tsx     # Expandable sections
  input.tsx         # Form inputs
  select.tsx        # Dropdowns
```

**Usage Example:**
```tsx
import { Button } from '@/components/ui/button'
import { Dialog, DialogContent, DialogTrigger } from '@/components/ui/dialog'

export function FlowSubmitDialog() {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant="outline" className="font-mono">
          Share Your Run
        </Button>
      </DialogTrigger>
      <DialogContent className="border-purple-500">
        {/* Form content */}
      </DialogContent>
    </Dialog>
  )
}
```

**Why This Works for RunExpression:**
- Components live in our codebase → full customization (change colors, fonts, animations)
- Radix UI handles accessibility → keyboard nav, ARIA attributes, focus management
- Tailwind integration → consistent with our existing styling approach
- Copy-paste approach → no version conflicts, no breaking changes from upstream

**Key Consequences:**
### Positive

- **Full control:** Own the code, modify components to match brand exactly
- **No bundle bloat:** Only include components you use (no unused code shipped)
- **Accessibility built-in:** Radix UI primitives handle complex ARIA patterns correctly
- **Tailwind integration:** Seamless styling with our existing Tailwind setup
- **No version lock-in:** Components don't break when "library" updates
- **TypeScript-first:** Excellent type safety and autocomplete
- **Fast iteration:** Copy component, customize, done (no fighting with CSS overrides)
- **Small bundle:** ~5-10KB per component (vs 300KB+ for full Material UI)

*[Full details in docs/adr/009-shadcn-ui.md]*

---

### 010-defer-sticker-studio

**File:** `docs/adr/010-defer-sticker-studio.md`

**Context:**
The original RunExpression vision included a **Sticker Studio** — a creative tool for users to design custom stickers, graphics, and visual elements using a Fabric.js-powered canvas editor.

**Sticker Studio Features (Original Spec):**
- Drag-and-drop canvas editor (similar to Canva or Figma)
- Library of running-themed clipart (shoes, trails, medals, bacon)
- Text overlays with custom fonts
- Layer management (bring to front, send to back)
- Export to PNG/SVG for sharing or printing
- Save designs to user profile
- Gallery of community-created stickers

**Use Cases:**
- Create custom race bib designs
- Design club logos and branding
- Make meme-style running stickers
- Compose visual journal entries for The Flow
- Create shareable quote graphics

**Technical Requirements:**
- Fabric.js (canvas manipulation library)
- Image upload and processing
- Asset library (clipart, fonts)
- Save/load design system (store canvas JSON in database)
- Export functionality (canvas → PNG/SVG)

**Current V1 Timeline:**
- 6-8 weeks to ship Homepage + Flow + Clubhouse + Blog
- Small team (1-2 devs)
- Need to focus on core value propositions

**Decision:**
We will **defer the Sticker Studio to V1.1** (or later) and focus V1 exclusively on:
1. **Homepage & Manifesto** (establish brand, drive traffic)
2. **The Flow** (core creative expression through text/photos)
3. **DWTC Clubhouse** (community archive and membership)
4. **Blog/Library** (thought leadership content)
5. **Shop Framework** (revenue generation)

**V1 Workaround:**
- Users can still upload images to The Flow (existing photos, screenshots)
- Users can create visual content outside RunExpression (Canva, Photoshop, phone apps) and upload results
- Pre-made sticker packs available in Shop (static graphics, not custom designs)

**V1.1 Implementation Plan:**
- Week 1: Fabric.js canvas setup, basic drawing tools
- Week 2: Asset library (clipart, fonts), layer management
- Week 3: Save/load designs, export to PNG/SVG
- Week 4: Polish, gallery, sharing features

**Key Consequences:**
### Positive

- **Faster V1 launch:** 6-8 weeks instead of 10-12 weeks (saves 2-4 weeks)
- **Focused scope:** Team can deliver polished core features instead of spreading thin
- **Reduced risk:** Fabric.js integration is complex (canvas state, performance, mobile compatibility) — defer to when we have more time
- **Better testing:** V1 launches with thoroughly tested features, not rushed creative tools
- **Clearer value prop:** V1 story is "write, share, connect" (not "design stickers")
- **Easier onboarding:** Fewer features to explain in initial launch
- **Revenue prioritization:** Shop framework delivers revenue immediately (stickers are nice-to-have)


*[Full details in docs/adr/010-defer-sticker-studio.md]*

---

### README

**File:** `docs/adr/README.md`

---

## Practical Guidelines for AI Agents

### When Writing Code

1. **Follow TypeScript standards** (DOCS/07-CODING-STANDARDS.md)
   - Always use explicit types
   - Prefer interfaces for objects
   - Use `unknown` instead of `any`

2. **Follow database conventions** (DOCS/08-DATABASE-CONVENTIONS.md)
   - Table names: plural, snake_case
   - Enable RLS on all tables
   - Use JSONB for flexible attributes

3. **Follow UI/UX patterns** (DOCS/09-UI-UX-PATTERNS.md)
   - Default to Server Components
   - Use Shadcn/UI components
   - Ensure WCAG AA accessibility

4. **Follow git workflow** (DOCS/10-GIT-WORKFLOW.md)
   - Use conventional commit format
   - Keep PRs small (<300 lines)
   - Write clear commit messages

### When Making Decisions

**Check ADRs first** (docs/adr/):
- Why Next.js App Router? → ADR-001
- Why Supabase? → ADR-002
- Why monolith? → ADR-003
- Why hybrid schema? → ADR-004
- Why MDX? → ADR-005
- Why Stripe Hosted Checkout? → ADR-006
- Why OpenAI Moderation? → ADR-007
- Why client-side compression? → ADR-008
- Why Shadcn/UI? → ADR-009
- Why defer sticker studio? → ADR-010

### When Implementing Features

**Refer to:**
- **Product requirements:** DOCS/02-PRODUCT-REQUIREMENTS.md
- **Technical design:** DOCS/03-TECHNICAL-DESIGN.md
- **Database schema:** DOCS/06-DATA-SCHEMA.md
- **Implementation plan:** DOCS/05-IMPLEMENTATION-PLAN.md

### When Reviewing Code

**Check:**
- TypeScript types are explicit
- RLS policies protect data
- Components are accessible (ARIA, keyboard nav)
- Commit messages follow conventional format
- Tests are included for new logic

### When Stuck

**Resources:**
1. Check relevant ADR for architectural context
2. Check DOCS/ for implementation details
3. Check coding standards for conventions
4. Ask for clarification if ambiguous

---

## Brand Voice & Philosophy

**From DOCS/04-BRAND-CONTENT-GUIDE.md:**

RunExpression is "The Sage in the Parking Lot" — deep but accessible, serious but lighthearted.

**Four Pillars:**
1. **Motion Creates Emotion** - Physical movement unlocks emotional processing
2. **Process Over Outcome** - The journey matters more than the destination
3. **Interdependence** - We need each other (shift from independence)
4. **Living Laboratory** - Experiment, learn, adapt

**Tone:** Vulnerable, honest, generative, invitational (not prescriptive)

---

## Common Patterns

### API Route Pattern
```typescript
// app/api/flow/submit/route.ts
export async function POST(request: Request) {
  try {
    // 1. Auth check
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()

    // 2. Validate input
    const body = await request.json()
    const result = schema.safeParse(body)
    if (!result.success) {
      return NextResponse.json({ error: result.error }, { status: 400 })
    }

    // 3. Process request
    const { data, error } = await supabase
      .from('table')
      .insert({ ...result.data, user_id: user?.id })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ data })
  } catch (error) {
    console.error('Error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```

### Component Pattern
```typescript
// components/flow/flow-post-card.tsx
import type { FlowPost } from '@/lib/types/flow'

interface FlowPostCardProps {
  post: FlowPost
}

export function FlowPostCard({ post }: FlowPostCardProps) {
  return (
    <div className="rounded-lg border p-6">
      {/* Component content */}
    </div>
  )
}
```

### Database Query Pattern
```typescript
// Fetch with RLS protection
const { data, error } = await supabase
  .from('expression_events')
  .select('id, content, created_at, profiles:user_id(full_name)')
  .eq('moderation_status', 'approved')
  .order('created_at', { ascending: false })
  .limit(20)
```

---

## Version History

| Date       | Changes                                      |
|------------|----------------------------------------------|
| 2025-12-14 | Initial AI Agent Guide generated             |

---

**Questions or unclear requirements?** Check the source documentation or ask for clarification.
